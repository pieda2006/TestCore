<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
      <title>hederahash</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="hederahash_files/katex.css">
      
      

      
      
      
      
      
      

      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h1 class="mume-header" id="hashgraph-consensus-example">HashGraph Consensus Example</h1>

<table>
<thead>
<tr>
<th>原文</th>
<th>翻訳</th>
</tr>
</thead>
<tbody>
<tr>
<td>This figure is a hashgraph.</td>
<td>この図はハッシュグラフです。</td>
</tr>
<tr>
<td>It grows upward over time.</td>
<td>それは時間の経過とともに上向きに成長します。</td>
</tr>
<tr>
<td>Every participant keeps a copy of it in memory.</td>
<td>すべての参加者はそれのコピーをメモリに保存します。</td>
</tr>
<tr>
<td>In this example, there are four members (full nodes) in the network.</td>
<td>この例では、ネットワーク内に4つのメンバー（フルノード）があります。</td>
</tr>
<tr>
<td>The members are Alice, Bob, Carol, Dave, and are represented by the 4 lines labeled A, B, C, D.</td>
<td>メンバーはAlice、Bob、Carol、Daveで、A、B、C、Dという4つの行で表されます。</td>
</tr>
<tr>
<td>Each member starts by creating an event, which is a small data 
structure in memory, and which is represented here by a gray circle.</td>
<td>各メンバーは、メモリ内の小さなデータ構造であり、<br>ここでは灰色の円で表されるイベントを作成することから始めます。</td>
</tr>
<tr>
<td>Each event is a container for zero or more transactions.</td>
<td>各イベントは、0個以上のトランザクションのコンテナです。</td>
</tr>
<tr>
<td>The goal of the Swirlds hashgraph consensus algorithm is for the 
members of the community to come to a consensus (agreement) on the order
 of the events (and thus the order of transactions inside the events), 
and to agree on a timestamp for each event (and so for each 
transaction).</td>
<td>Swirldsハッシュグラフ合意アルゴリズムの目的は、<br>コミュニティのメンバーがイベントの順序（したがってイベント内のトランザクションの順序）について合意（合意）し、<br>各イベントのタイムスタンプについて合意することです。 （そして各トランザクションについても同様）。</td>
</tr>
<tr>
<td>It should be hard for attackers to prevent consensus, or to force 
different members to come to a different “consensus”, or to unfairly 
influence the order and timestamps that are agreed.</td>
<td>攻撃者がコンセンサスを妨げたり、異なるメンバーに異なる「コンセンサス」を強制したり、<br>合意された順序やタイムスタンプに不当に影響を与えることは困難です。</td>
</tr>
</tbody>
</table>
<p><img src="hederahash_files/001.jpg" alt=""><br>
The community runs a gossip protocol, which means that each member repeatedly calls others at random to sync with them.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>コミュニティはゴシッププロトコルを実行します。つまり、各メンバーはランダムに他のメンバーに電話をかけて同期します。
</code></pre><p>In this case, Bob randomly chose to call Dave.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この場合、BobはランダムにDaveを呼び出すことを選択しました。
</code></pre><p>When they connected over the internet, Bob sent Dave all the events he knew that Dave did not yet know.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>彼らがインターネットを介して接続したとき、ボブはデイブがまだ知らないすべての出来事をデイブに送った。
</code></pre><p>In this case, it was just one event: the one that Bob had created at the start.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この場合、それはただ1つのイベントでした。ボブが最初に作成したものです。
</code></pre><p>Dave records the fact that this sync happened by creating a new event.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>Daveは、この同期が新しいイベントを作成することによって行われたという事実を記録します。
</code></pre><p>This is the new circle, which has lines going straight down to his own last event, and diagonally down to Bob’s last event.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>これは新しい円で、直線は彼自身の最後のイベントまで、そして斜めにボブの最後のイベントまで続いています。
</code></pre><p>Thus, the graph of events forms a record of how the members have communicated.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>したがって、イベントのグラフは、メンバーがどのように伝達したかの記録を形成します。
</code></pre><ul>
<li>TECHNICAL DETAIL<br>
Bob can avoid sending Dave events he already knows.<pre data-role="codeBlock" data-info="" class="language-"><code>ボブは、彼がすでに知っているDaveイベントを送信することを避けることができます。
</code></pre>Bob first tells Dave how many events he knows about that were created by each member (i.e., 4 integers).<pre data-role="codeBlock" data-info="" class="language-"><code>ボブは最初に、彼がそれについて知っているイベントが各メンバーによっていくつ発生したかをDaveに伝えます（すなわち、4つの整数）。
</code></pre>Dave tells Bob the same.<pre data-role="codeBlock" data-info="" class="language-"><code>デイブはボブに同じことを言う。
</code></pre>Then they will both know exactly which events each should send the other.<pre data-role="codeBlock" data-info="" class="language-"><code>それから、両者はどちらのイベントがお互いに送信するべきかを正確に知るでしょう。
</code></pre>If Bob has 13 events by Alice and Dave has 10, then Bob sends Alice’s last 3 events.<pre data-role="codeBlock" data-info="" class="language-"><code>ボブがアリスによる13のイベントを持ち、デイブが10のイベントを持っている場合、ボブはアリスの最後の3つのイベントを送ります。
</code></pre></li>
</ul>
<p><img src="hederahash_files/002.jpg" alt=""></p>
<p>Dave’s new event is illustrated here.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>Daveの新しいイベントがここに示されています。
</code></pre><p>An event is a data structure containing the two hashes of the two events below itself (its self-parent and its other-parent).</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>イベントは、それ自身の下にある2つのイベントの2つのハッシュを含むデータ構造体です（自己の親と他の親）。
</code></pre><p>In this case, the self-parent is Dave’s first event, and the other-parent is Bob’s first event.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この場合、自分の親がDaveの最初のイベントで、もう一方の親がBobの最初のイベントです。
</code></pre><p>The event can optionally contain zero or more transactions that Dave wants to send to the network.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>イベントには、Daveがネットワークに送信したいトランザクションを0個以上含めることができます。
</code></pre><p>So an event is a container for transactions.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>そのため、イベントはトランザクションのコンテナです。
</code></pre><p>Dave also puts a timestamp of when he created the event. He then digitally signs it.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>Daveはまた、イベントを作成したときのタイムスタンプも付けます。 それから彼はそれにデジタル署名します。
</code></pre><p>When this event is gossiped, the signature will be sent along with it.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>このイベントがゴシップ化されると、署名も一緒に送信されます。
</code></pre><p><img src="hederahash_files/004.jpg" alt=""></p>
<p>Dave then sends Bob all his events (including the new one he just created).</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>次にDaveは、自分が作成した新しいイベントも含めて、自分のすべてのイベントをBobに送信します。
</code></pre><p>Bob then creates a new event recording the fact they 
synced, and including the hashes of the most recent event by himself and
 the most recent event by Dave.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>次にボブは、同期した事実を記録した新しいイベントを作成します。
自分自身による最新のイベントとDaveによる最新のイベントのハッシュも含まれます。
</code></pre><p><img src="hederahash_files/005.jpg" alt=""></p>
<p>Bob then randomly chooses Alice, and sends her all 4 events he knows about.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>次にボブはランダムにアリスを選び、彼が知っている4つのイベントすべてを彼女に送ります。
</code></pre><p>She creates a new one.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>彼女は新しいものを作ります。
</code></pre><p><img src="hederahash_files/006.jpg" alt=""></p>
<p>This continues forever, growing a directed acyclic graph upwards forever.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>これは永遠に続き、有向非巡回グラフを永遠に上向きに成長させます。
</code></pre><p>This is a graph connected by cryptographic hashes, so it is called a hashgraph.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>これは暗号化ハッシュによって接続されたグラフなので、ハッシュグラフと呼ばれます。
</code></pre><p>Each event contains the hashes of the events below it and is digitally signed by its creator.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>各イベントには、その下のイベントのハッシュが含まれており、作成者によってデジタル署名されています。
</code></pre><p>So the entire graph of hashes is cryptographically secure.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>したがって、ハッシュのグラフ全体は暗号的に安全です。
</code></pre><p>It can always grow, but the older parts are immutable, as strong as the cryptographic hash and signature system used.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それは常に成長する可能性がありますが、古い部分は不変であり、使用される暗号化ハッシュおよび署名システムと同じくらい強力です。
</code></pre><p><img src="hederahash_files/007.jpg" alt=""></p>
<p>It is useful to define a round created for each event.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>各イベントに対して作成されたラウンドを定義すると便利です。
</code></pre><p>A child never has a round created before one of its parents.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>子供がその親のうちの1人の前にラウンドを作成することはありません。
</code></pre><p>So as time flows upward in the diagram, the round created can only stay the same or increase.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>そのため、ダイアグラムで時間が上向きに流れるにつれて、作成されたラウンドは同じままであるか増加するだけです。
</code></pre><p>A later slide will describe how the round created is calculated.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>後のスライドで、作成されたラウンドの計算方法について説明します。
</code></pre><p>The important point is that as soon as you receive an event in a sync, you can immediately calculate its round created.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>重要な点は、同期でイベントを受信したらすぐに、作成したラウンドをすぐに計算できることです。
</code></pre><p>And anyone else receiving it will calculate the same number.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>そしてそれを受け取った他の誰もが同じ数を計算するでしょう。
</code></pre><p>Guaranteed.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>保証します。
</code></pre><ul>
<li>TECHNICAL DETAIL:<br>
The definition is: the round created for an event is R or R+1, where R is the max of the round created of its parents.<pre data-role="codeBlock" data-info="" class="language-"><code>定義は次のとおりです。イベントに対して作成されたラウンドはRまたはR + 1です。ここで、Rはその親から作成されたラウンドの最大値です。
</code></pre>It is R+1 if and only if it can strongly see a supermajority of round R witnesses.<pre data-role="codeBlock" data-info="" class="language-"><code>ラウンドRの目撃者の超大多数を強く見ることができる場合に限り、それはR + 1です。
</code></pre>This is explained in greater detail in later slides.<pre data-role="codeBlock" data-info="" class="language-"><code>これについては、後のスライドで詳しく説明します。
</code></pre></li>
</ul>
<p><img src="hederahash_files/008.jpg" alt=""></p>
<p>The first event that Alice creates in each round is called a witness.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>アリスが各ラウンドで作成する最初のイベントは証人と呼ばれます。
</code></pre><p>Her witnesses are labeled A1, A2, and A3 here.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>彼女の証人はここでA1、A2、そしてA3とラベル付けされている。
</code></pre><p>The other members create witnesses similarly.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>他のメンバーも同様に証人をつくります。
</code></pre><p>It is possible for a member to have no witnesses in a given round.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>与えられたラウンドで会員が証人を持つことはできません。
</code></pre><ul>
<li>TECHNICAL DETAIL:<br>
It is possible for a member to cheat by forking, or creating two events with the same self parent.<pre data-role="codeBlock" data-info="" class="language-"><code>メンバーがフォークすること、または同じ親を持つ2つのイベントを作成することによってカンニングすることは可能です。
</code></pre>In that case, there might be two witnesses in the same round by the same member.<pre data-role="codeBlock" data-info="" class="language-"><code>その場合、同じメンバーによる同じラウンドに2人の目撃者がいるかもしれません。
</code></pre>There are theorems proving that this won’t matter.<pre data-role="codeBlock" data-info="" class="language-"><code>これが問題にならないことを証明する定理があります。
</code></pre></li>
</ul>
<p><img src="hederahash_files/009.jpg" alt=""></p>
<p>For each witness, we need to determine if it is a famous witness.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>証人ごとに、それが有名な証人かどうかを判断する必要があります。
</code></pre><p>For example, we will determine if the witness B2 is a famous witness.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>たとえば、証人B2が有名な証人であるかどうかを判断します。
</code></pre><p>This is done by considering the witnesses in the next round.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>これは次のラウンドの目撃者を考慮することによって行われます。
</code></pre><p>So the fame of B2 will be determined by first considering the witnesses A3, B3, C3, and D3.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>したがって、B2の名声は、証人A3、B3、C3、およびD3を最初に検討することによって決定されます。
</code></pre><p>The idea is for B2 to count as famous if it is seen by many of the witnesses in the next round.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>次のラウンドで多くの目撃者に見られるようになれば、B2は有名であると数えることができます。
</code></pre><p>There is now an election, in which each of those witnesses will vote on whether B2 is famous.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>今選挙があり、その中でそれらの目撃者のそれぞれがB2が有名であるかどうかについて投票するでしょう。
</code></pre><p>There will be a separate election for every witness, to determine its fame.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>その名声を決定するために、目撃者ごとに別々の選挙があります。
</code></pre><p><img src="hederahash_files/010.jpg" alt=""></p>
<p>The witness A3 can see B2. That means that there is an entirely-downward path from A3 to B2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>証人A3はB2を見ることができます。 つまり、A3からB2への完全に下向きのパスがあるということです。
</code></pre><p>In other words, B2 is an ancestor of A3.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>言い換えれば、B2はA3の先祖です。
</code></pre><p>And A3 is a descendent of B2 A3 can see B2, so A3 will vote YES in the election for whether B2 is famous.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>そしてA3はB2の子孫ですA3はB2を見ることができるので、A3はB2が有名であるかどうかのために選挙でYESに投票します。
</code></pre><ul>
<li>TECHNICAL DETAIL:<br>
A3 sees all its ancestors except for those created by a member who created a fork that is an ancestor of A3.<pre data-role="codeBlock" data-info="" class="language-"><code>A3は、A3の先祖であるフォークを作成したメンバーによって作成されたものを除いて、そのすべての先祖を見ます。
</code></pre>In other words, A3 can see B2 if B2 is an ancestor of A3, 
and the creator of B2 (who is Bob) did not create two events X and Y 
that both have the same self-parent and are both ancestors of A3.<pre data-role="codeBlock" data-info="" class="language-"><code>つまり、B2がA3の先祖であり、B2の作成者（Bob）が、同じ親を持ち、
両方ともA3の先祖である2つのイベントXとYを作成しなかった場合、A3はB2を見ることができます。
</code></pre>So “seeing” is the same as “ancestor”, except you can’t “see” cheaters.<pre data-role="codeBlock" data-info="" class="language-"><code>つまり、「見る」ことは「祖先」と同じです。ただし、不正行為者を「見る」ことはできません。
</code></pre></li>
</ul>
<p><img src="hederahash_files/011.jpg" alt=""></p>
<p>B3 sees B2, so it votes YES. C3 sees B2, so it votes YES.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>B3はB2を見ているので、YESと投票します。 C3はB2を見ているので、YESと投票します。
</code></pre><p><img src="hederahash_files/012.jpg" alt=""> <img src="hederahash_files/013.jpg" alt=""></p>
<p>D3 sees B2, so it votes YES.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>D3はB2を見ているので、YESと投票します。
</code></pre><p>All four witnesses voted YES, so we would expect that B2 will be declared to be famous.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>4人の証人全員がイエスに投票したので、B2が有名になると宣言されるでしょう。
</code></pre><p>But the election isn’t over yet! An election isn’t over until the votes are counted.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>しかし、選挙はまだ終わっていません！ 投票がカウントされるまで選挙は終わらない。
</code></pre><p>The votes will be counted by the witnesses in the following round.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>投票は次のラウンドで証人によってカウントされます。
</code></pre><p>So B4 will count the votes. And D4 will also count the votes.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>だからB4は票を数えるでしょう。 そしてD4も投票を数えます。
</code></pre><p>The hashgraph doesn’t yet have an A4 or C4.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>ハッシュグラフにはまだA4またはC4がありません。
</code></pre><p>But as time goes on and more gossiping occurs, there may eventually be an A4 and C4, and then they will count the votes, too.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>しかし、時間が経つにつれてゴシップが発生するにつれて、最終的にはA4とC4が発生する可能性があり、その後、投票数もカウントされます。
</code></pre><p><img src="hederahash_files/014.jpg" alt=""></p>
<p>B4 will collect the votes from every round-3 witness that it strongly sees.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>B4は、それが強く見ているすべてのラウンド3目撃者から投票を集めるでしょう。
</code></pre><p>To strongly see a witness, it isn’t enough for there to be a single downward path to it.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>目撃者を強く見るためには、それへの単一の下向きの道があるだけでは十分ではありません。
</code></pre><p>There must be enough different paths to it so that together, the paths go through a supermajority of the population.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>一緒になって、その道が人口の超大多数を通るように、それへの十分に異なる道がなければなりません。
</code></pre><p>A supermajority is any number that is more than two 
thirds of the population. In this example, there are 4 members in the 
population, so any 3 of them constitute a supermajority.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>超大衆とは、人口の3分の2を超える数です。この例では、母集団に4人のメンバーがいるので、そのうちの3人は超大多数を構成します。
</code></pre><p>In this example, B4 is able to strongly see A3.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この例では、B4はA3を強く見ることができます。
</code></pre><p>The red path goes from B4 to A3 through Alice and Bob.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>赤い道はアリスとボブを通ってB4からA3に行きます。
</code></pre><p>The green path goes through Alice, Bob, and Dave. There are no paths from B4 that go through Carol to get to A3.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>緑の道はアリス、ボブ、そしてデイブを通ります。キャロルを通過してA3に到達するB4からのパスはありません。
</code></pre><p>But that’s OK, because Alice, Bob, and Dave make up a supermajority.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>しかし、それは問題ありません。アリス、ボブ、そしてデイブが大部分を占めているからです。
</code></pre><p>So Carol isn’t needed.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>だからキャロルは必要ない。
</code></pre><p>In fact, the green path alone would have been enough.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>実際には、グリーンパスだけで十分でしょう。
</code></pre><p>The red path wasn’t needed.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>赤い道は必要ではなかった。
</code></pre><p>So, B4 can strongly see A3. Therefore, B4 collects the vote from A3 (which is YES).</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それで、B4はA3を強く見ることができます。したがって、B4はA3から投票を収集します（YES）。
</code></pre><p><img src="hederahash_files/015.jpg" alt=""></p>
<p>B4 strongly sees B3, because the red path goes through Alice and Bob, and the green path goes through Bob and Dave.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>赤い道はアリスとボブを通り、緑の道はボブとデイブを通るので、B4はB3を強く見ます。
</code></pre><p>In this case, both paths were needed to reach the supermajority.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この場合、両方の経路が超大多数に到達するために必要でした。
</code></pre><p>B4 strongly sees C3, and so collects another YES vote.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>B4はC3を強く見ているので、別のYES投票を集めます。
</code></pre><ul>
<li>TECHNICAL DETAIL:<br>
if a path starts at Bob and ends at Carol, then it automatically counts as going through Bob and Carol.<pre data-role="codeBlock" data-info="" class="language-"><code>パスがボブで始まりキャロルで終わる場合は、自動的にボブとキャロルを通るものとしてカウントされます。
</code></pre>In other words, the endpoints of the path are counted, too.<pre data-role="codeBlock" data-info="" class="language-"><code>つまり、パスの終点もカウントされます。
</code></pre></li>
</ul>
<p>B4 strongly sees D3, and so collects another YES vote.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>B4はD3を強く見ているので、別のYES投票を集めます。
</code></pre><p><img src="hederahash_files/016.jpg" alt=""> <img src="hederahash_files/017.jpg" alt=""> <img src="hederahash_files/018.jpg" alt=""></p>
<p>At this point, B4 has received YES notes from a supermajority, so B4 decides that the election result is YES.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この時点で、B4は超大多数からYESのメモを受け取っているので、B4は選挙結果がYESであると判断します。
</code></pre><p>Color B2 green to show that it is now famous.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それが今有名であることを示すためにカラーB2グリーン。
</code></pre><p>That is the consensus decision.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それが合意の決定です。
</code></pre><p>If B4 had seen 3 YES and 1 NO, it would still decide YES, because that’s a supermajority.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>もしB4が3つのYESと1つのNOを見たなら、それはまだYESと決定するでしょう、それはそれが超大国であるので。
</code></pre><p>If B4 had seen 3 YES votes and no other votes (because 
it couldn’t strongly see one of the witnesses), it would still decide 
YES, because that’s a supermajority.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>B4が3人のYES票を見て、他の票を見たことがなければ（証人の1人を強く見ることができなかったので）、
それでもYESを決定するでしょう。それは超大国であるためです。
</code></pre><p>We need for B4 to strongly see a supermajority of witnesses, in order to even have a chance at deciding.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>決断を下すチャンスさえも得るために、私たちはB4が証人の超大多数を強く見ることが必要です。
</code></pre><p>Therefore, we use this to define the round created.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>したがって、作成したラウンドを定義するためにこれを使用します。
</code></pre><p>If an event X has parents with a maximum round created of R, then that event will usually be round R, too.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>イベントXがRで作成された最大ラウンドを持つ親を持つ場合、そのイベントは通常Rラウンドでもあります。
</code></pre><p>But if that event can strongly see a supermajority of 
round R witnesses, then that event is defined to be round R+1, and so is
 a witness.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>しかし、その出来事がラウンドRの目撃者の超大多数を強く見ることができるのであれば、
そのイベントはラウンドR + 1であると定義されているので、証人でもあります。
</code></pre><p>In other words, an event is promoted to the next round 
when it can strongly see a supermajority of witnesses in the current 
round.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>言い換えれば、あるイベントが次のラウンドに昇格するのは、現在のラウンドで非常に多くの目撃者がいることを強く示しているからです。
</code></pre><p><img src="hederahash_files/019.jpg" alt=""></p>
<p>Now we run an election for whether C2 is famous.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>今度は、C2が有名かどうかの選挙を行います。
</code></pre><p>The yellow path shows that C3 can see C2, and so C3 votes yes.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>黄色のパスは、C3がC2を認識できることを示しているため、C3は「はい」と投票します。
</code></pre><p>There are no downward paths from A3, B3, or D3 to C2, so they all vote NO.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>A3、B3、またはD3からC2への下向きのパスはありません。したがって、これらはすべてNOと投票します。
</code></pre><p>Since B4 strongly sees all of A3, B3, C3, and D3, it will therefore collect votes from all of them.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>B4はA3、B3、C3、およびD3のすべてを強く認識しているので、したがってそれらのすべてから投票を収集します。
</code></pre><p>The votes are NO, NO, YES, NO.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>投票は、NO、NO、YES、NOです。
</code></pre><p>So a supermajority is NO.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それで、超大多数はNOです。
</code></pre><p>So it decides NO.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それでそれはNOを決定します。
</code></pre><p>The election is over.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>選挙は終わりました。
</code></pre><p>C2 is not famous. Color it blue to show that it is not famous.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>C2は有名ではありません。 それが有名でないことを示すためにそれを青に着色してください。
</code></pre><p><img src="hederahash_files/020.jpg" alt=""> <img src="hederahash_files/021.jpg" alt=""></p>
<p>There is a theorem that if any witness is able to “decide” yes or no,
 then that is the result of the election, and it is guaranteed that all 
other witnesses that decide are going to decide the same way.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>いずれかの証人が「はい」または「いいえ」を「決定」することができれば、
それが選挙の結果であり、決定する他のすべての証人が同じように決定することが保証されるという定理があります。
</code></pre><p>In this example, B4 was able to decide the election.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この例では、B4が選挙を決めることができました。
</code></pre><p>If it had collected votes that were more evenly split between YES and NO, then it would have failed to decide.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>もしそれがYESとNOの間でより均等に分割された投票を集めていたら、それは決定に失敗したでしょう。
</code></pre><p>In that case, we can consider D4. If D4 also fails to decide, then perhaps A4 or C4 might decide.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>その場合、D4を検討できます。 D4も決定できない場合は、おそらくA4またはC4が決定する可能性があります。
</code></pre><p>If none of the round-4 witnesses can decide, then each 
of them will simply vote in accordance with the majority of the votes 
they collected (voting YES in case of a tie).</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>第4ラウンド目撃者の誰もが決定することができないならば、
それから彼らのそれぞれは単に彼らが集めた投票の大半に従って投票するでしょう（同点の場合YES）。
</code></pre><p>In that case, it will be up to the round-5 witnesses to collect votes from the round-4 witnesses.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>その場合、第4ラウンド目撃者から投票を集めるのは第5ラウンド目撃者になります。
</code></pre><p>Perhaps the round-5 witnesses will be able to decide.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>おそらく第5ラウンド目撃者が決めることができるでしょう。
</code></pre><p>The voting continues until it eventually reaches a round where some witness can decide the election.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>投票は最終的に何人かの目撃者が選挙を決定できるラウンドに達するまで続きます。
</code></pre><p>There is a theorem saying that the election will 
eventually end (with probability one) as long as we add in a coin round 
every 10 th round of voting.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>投票の10ラウンドごとにコインラウンドを追加する限り、選挙は最終的に（確率1で）終了するという定理があります。
</code></pre><p>In a coin round, collecting a supermajority causes a witness to merely vote (not decide).</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>コインラウンドでは、超大多数を集めると、証人は単に投票するだけになります（決定しません）。
</code></pre><p>And a non-supermajority causes it to vote pseudorandomly, by using the middle bit of its own signature as its vote.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>そして、非超大国主義は、それ自身の署名の真ん中のビットをその投票として使用することによって、それを疑似ランダムに投票させる。
</code></pre><p><img src="hederahash_files/022.jpg" alt=""></p>
<p>6 more elections are run. They decide that A2, D2, A1, B1, C1, and D1 are all famous.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>さらに6選挙が実行されます。 彼らは、A2、D2、A1、B1、C1、およびD1がすべて有名であると決定します。
</code></pre><p>In normal operation, most events are not witnesses, so there is no election for most events.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>通常の運用では、ほとんどのイベントは目撃者ではないため、ほとんどのイベントに選挙はありません。
</code></pre><p>And most witnesses are declared famous with an almost-unanimous vote in the first round of voting.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>そして、ほとんどの目撃者は、投票の最初のラウンドでほぼ全会一致の投票で有名に宣言されています。
</code></pre><p>So most elections do not last very long.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>だからほとんどの選挙はそれほど長くは続かない。
</code></pre><p>Notice that in this example, we have now decided the fame of every witness in round 2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この例では、第2ラウンドですべての証人の名声を決めました。
</code></pre><p>Once a round has the fame decided for all of its 
witnesses, it is possible to find the round received and find the 
consensus timestamp for a new set of events.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>あるラウンドでその証人全員の名声が決定したら、受け取ったラウンドを見つけて、
新しい一連のイベントの合意タイムスタンプを見つけることができます。
</code></pre><p>Start by considering the gray event immediately below A2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>A2のすぐ下のグレーのイベントを検討することから始めます。
</code></pre><ul>
<li>TECHNICAL DETAIL:<br>
If a member forks, they might have two famous witnesses in the same round.<pre data-role="codeBlock" data-info="" class="language-"><code>メンバーがフォークする場合、彼らは同じラウンドに2人の有名な目撃者を持つかもしれません。
</code></pre>In that case, neither of them are used further.<pre data-role="codeBlock" data-info="" class="language-"><code>その場合、どちらもそれ以上使用されません。
</code></pre>Only the remaining ones (the “unique famous witnesses”) are used to determine round received and consensus timestamp.<pre data-role="codeBlock" data-info="" class="language-"><code>残りの1人（「ユニークな有名な証人」）だけが、受信ラウンドと合意タイムスタンプの決定に使用されます。
</code></pre></li>
</ul>
<p><img src="hederahash_files/024.jpg" alt=""></p>
<p>This event can be seen by every famous witness in round 2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この出来事は、ラウンド2のすべての有名な目撃者に見られます。
</code></pre><p>The red, green, and blue paths show how A2, B2, and D2, respectively, can all see the black event.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>赤、緑、青のパスは、それぞれA2、B2、D2が黒のイベントをどのように認識できるかを示しています。
</code></pre><p>This merely requires seeing, not strongly seeing.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>これは単に見ることを要求し、強く見ることは要求しません。
</code></pre><p>This only requires seeing by the famous witnesses.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>これはただ有名な目撃者によって見ることを必要とします。
</code></pre><p>It doesn’t matter whether C2 can see the black event, because C2 is not famous.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>C2が有名ではないので、C2が黒のイベントを見ることができるかどうかは重要ではありません。
</code></pre><p>Since the black event is seen by all of the famous 
witnesses in round 2 (but not in any earlier round), it is said to have a
 round received of 2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>黒の出来事は第2ラウンドで有名な目撃者全員に見られますが（それ以前のどのラウンドでもそうではありません）、
それは2のラウンドを受けたと言われています。
</code></pre><ul>
<li>TECHNICAL DETAIL:<br>
we don’t need to limit ourselves to “seeing”.<pre data-role="codeBlock" data-info="" class="language-"><code>見ることだけに制限する必要はありません。
</code></pre>It is sufficient to use the “ancestor” relationship instead.<pre data-role="codeBlock" data-info="" class="language-"><code>代わりに「先祖」関係を使用すれば十分です。
</code></pre>In other words, at this step, we don’t worry about forking.<pre data-role="codeBlock" data-info="" class="language-"><code>つまり、この段階では、フォークについて心配する必要はありません。
</code></pre></li>
</ul>
<p>The consensus timestamp of the black event can be found as follows.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>ブラックイベントの合意タイムスタンプは以下のように見つけることができます。
</code></pre><p>Find the earliest event X by Alice that is an ancestor of A2 and a descendent of the black event.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>A2の祖先であり、黒い出来事の子孫であるAliceによる最も初期の出来事Xを見つけなさい。
</code></pre><p>Similarly, find the earliest event Y by Bob that is an ancestor of B2 and descendent of the black event.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>同様に、B 2の祖先であり、黒のイベントの子孫であるBobによる最も初期のイベントYを見つけます。
</code></pre><p>And similarly for event Z by Dave.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>そして、DaveによるイベントZについても同様です。
</code></pre><p>Take the timestamps on the events X, Y, Z that were put in those events by their creators.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>作成者によってこれらのイベントに追加されたイベントX、Y、Zのタイムスタンプを取得します。
</code></pre><p>Sort all of the timestamps in order.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>すべてのタイムスタンプを順番に並べ替えます。
</code></pre><p>Take the middle one from the list (or the second of the two middle ones, if there are an even number of them).</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>リストから真ん中のものを選ぶ（偶数の場合は2つの真ん中のもののうち2番目のもの）。
</code></pre><p>This median timestamp is the consensus timestamp for the black event.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この中央タイムスタンプは、黒のイベントの合意タイムスタンプです。
</code></pre><p><img src="hederahash_files/025.jpg" alt=""></p>
<p>Now consider the gray event below B2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それではB2の下にある灰色のイベントについて考えてみましょう。
</code></pre><p>It is seen by B2, but not seen by A2 or D2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それはB2によって見られますが、A2またはD2によって見られません。
</code></pre><p>So it was not seen by all the famous witnesses in round 2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それで、それはラウンド2のすべての有名な目撃者によって見られませんでした。
</code></pre><p>So its received round will be later than round 2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>そのため、受信したラウンドはラウンド2より遅くなります。
</code></pre><p>Leave it colored gray to indicate that it doesn’t yet have a received round.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>まだ受信ラウンドが行われていないことを示すために、灰色のままにします。
</code></pre><p><img src="hederahash_files/026.jpg" alt=""></p>
<p>Continuing, we find consensus for the 6 black events and the 4 dark green events.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>続けて、我々は6つの黒い出来事と4つの濃い緑色の出来事について一致を見つけます。
</code></pre><p>These are the 10 events that have a round received of 2.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>これらは、2のラウンドを受け取った10のイベントです。
</code></pre><p>We need to sort these 10 events into an order that all members will agree on.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>私たちはこれらの10のイベントをすべてのメンバーが同意する順序に分類する必要があります。
</code></pre><p>This agreed order is the consensus order.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この合意された順序は合意順序です。
</code></pre><p>This is done by sorting them by round received.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>これは受信したラウンドによってそれらをソートすることによって行われます。
</code></pre><p>Ties are broken by sorting by the median timestamp (which is the consensus timestamp).</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>ネクタイは、中央値のタイムスタンプ（合意タイムスタンプ）でソートすることによって分割されます。
</code></pre><p>Further ties are broken by sorting by the extended median (which looks at more than just the middle element of each list).</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>それ以上の関係は拡張中央値（各リストのちょうど中間の要素以上を見る）でソートすることによって破られます。
</code></pre><p>Further ties are broken by sorting them by their 
signatures, after all the signatures have been XORed with a pseudorandom
 number.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>すべてのシグネチャが疑似乱数とXORされた後、さらにそのネクタイはそれらのシグネチャによってそれらをソートすることによって壊されます。
</code></pre><p>The pseudorandom number for a given round received is found by XORing the signatures of all the famous witnesses in that round.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>与えられたラウンドの疑似乱数は、そのラウンドのすべての有名な証人の署名をXORすることによって求められます。
</code></pre><p><img src="hederahash_files/027.jpg" alt=""></p>
<p>This picture is a screenshot from the HashgraphDemo app that is part of the Swirlds SDK that can be downloaded from <a href="http://swirlds.com/">Swirlds.com</a>.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>この写真は、Swirlds.comからダウンロードできるSwirlds SDKの一部であるHashgraphDemoアプリのスクリーンショットです。
</code></pre><p>This screenshot came from running it in slow mode with 4 members, with the checkbox checked to show the round created.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>このスクリーンショットは、作成されたラウンドを表示するためにチェックボックスがチェックされた状態で、
4人のメンバーでスローモードで実行されたものです。
</code></pre><p>This screenshot shows the part of the hashgraph from about round 100 to 105.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>このスクリーンショットは、ラウンド100から105までのハッシュグラフの一部を示しています。
</code></pre><p>The example is a slightly-modified version of the top half of this screenshot.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>例は、このスクリーンショットの上半分を少し修正したものです。
</code></pre><p><img src="hederahash_files/028.jpg" alt=""></p>
<h1 class="mume-header" id="whitepaper">WhitePaper</h1>

<h2 class="mume-header" id="vision">Vision</h2>

<p>The Hedera Hashgraph Council will provide governance for an open, 
fast and fair decentralized public ledger built on the hashgraph 
consensus algorithm.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>Hedera Hashgraph Councilは、ハッシュグラフコンセンサスアルゴリズムに基づいて構築された、
オープンで高速かつ公正な分散型の公開元帳にガバナンスを提供します。
</code></pre><p>Governance will be maintained by a council of up to 39 
known and reputable global organizations, committed to the support and 
evolution of a stable, predictable public ledger infrastructure.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>ガバナンスは、安定した予測可能な公共台帳インフラストラクチャのサポートと進化を約束する、
最大39の有名で信頼できるグローバル組織の協議会によって維持されます。
</code></pre><h2 class="mume-header" id="executive-summary">Executive Summary</h2>

<p>Distributed ledger technologies (DLT) are disrupting and transforming existing markets in multiple industries.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>分散元帳テクノロジ（DLT）は、さまざまな業界の既存市場を混乱させ、変化させています。
</code></pre><p>However, in our opinion there are five fundamental 
obstacles to overcome before distributed ledgers can be widely accepted 
and adopted across every industry and geography.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>しかし、私たちの意見では、分散した元帳があらゆる業界や地域で広く受け入れられ採用される前に克服すべき5つの基本的な障害があります。
</code></pre><p>In this paper we will examine these obstacles, and 
discuss why Hedera hashgraph is ideally suited to be the world’s first 
mass-adopted public distributed ledger, supporting a vast array of 
applications.</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>このホワイトペーパーでは、これらの障害を検証し、Hedera hashgraphが、世界で最初に大量採用された公開分散元帳に最適で、
さまざまなアプリケーションをサポートするのに最適な理由を説明します。
</code></pre><ol>
<li>PERFORMANCE<br>
The most compelling use cases require hundreds of thousands of 
transactions per second in a single shard (perhaps millions of 
transactions per second (tps) in a fully-sharded solution), and many 
require consensus latency measured in seconds.<pre data-role="codeBlock" data-info="" class="language-"><code>最も魅力的なユースケースでは、単一の断片で毎秒数十万トランザクション
（完全に分割されたソリューションではおそらく毎秒数百万トランザクション（tps））が必要であり、
多くの場合、秒単位の合意待ち時間が必要です。
</code></pre>These performance metrics are orders of magnitude beyond what current public DLT platforms can achieve.<pre data-role="codeBlock" data-info="" class="language-"><code>これらのパフォーマンス指標は、現在の公衆DLTプラットフォームが達成できるものをはるかに超えるものです。
</code></pre></li>
<li>SECURITY<br>
If public platforms are to facilitate the transfer of trillions of 
dollars of value, we have to expect them to be targeted, and we have to 
prepare for this.<pre data-role="codeBlock" data-info="" class="language-"><code>公共のプラットフォームが何兆ドルもの価値の移転を促進するのであれば、
それらがターゲットにされることを期待しなければならず、そしてこれに備えなければなりません。
</code></pre>To do so requires a consensus algorithm that provides the 
best security one can achieve, with the security properties of the 
algorithm formally proven.<pre data-role="codeBlock" data-info="" class="language-"><code>そのためには、アルゴリズムのセキュリティ特性が正式に証明された、
達成可能な最高のセキュリティを提供するコンセンサスアルゴリズムが必要です。
</code></pre>Vectors of security vulnerabilities shouldn’t be mitigated; they should be eliminated entirely.<pre data-role="codeBlock" data-info="" class="language-"><code>セキュリティの脆弱性のベクトルを軽減するべきではありません。 それらは完全に排除されるべきです。
</code></pre>Other public DLT platforms are trading off decentralization (and so potentially compromising security) for performance gains.<pre data-role="codeBlock" data-info="" class="language-"><code>他の公衆DLTプラットフォームでは、パフォーマンスの向上のために分散化（およびそのため潜在的にセキュリティの低下）が相殺されています。
</code></pre></li>
<li>GOVERNANCE<br>
A general-purpose public ledger should be governed by representatives 
from a broad range of market sectors, each with world-class expertise in
 their respective industries, and also selected to provide global 
geographic representation for all markets.<pre data-role="codeBlock" data-info="" class="language-"><code>汎用の総勘定元帳は、それぞれの業界で世界クラスの専門知識を持つ幅広い市場部門の代表によって統治され、
またすべての市場にグローバルな地理的代表を提供するように選択されるべきです。
</code></pre>Those that are governing need technical expertise so they can competently manage the technical roadmap.<pre data-role="codeBlock" data-info="" class="language-"><code>管理している人たちは技術的な専門知識が必要です。そうすれば彼らは技術的なロードマップをうまく管理することができます。
</code></pre>They need business expertise so they can manage business 
operations of the organization. They need expertise in economics and 
currency markets so they can manage the cryptocurrency.<pre data-role="codeBlock" data-info="" class="language-"><code>組織の事業運営を管理できるようにするには、ビジネスの専門知識が必要です。
彼らは暗号通貨を管理することができるように経済学と通貨市場の専門知識を必要とします。
</code></pre>They need legal expertise to help navigate the evolving regulatory environment.<pre data-role="codeBlock" data-info="" class="language-"><code>彼らは、進化する規制環境の中を進むのに役立つ法的専門知識を必要としています。
</code></pre>In other words, governance should be by those globally 
recognized as world leaders in their respective industries, and 
representative of every market in the world.<pre data-role="codeBlock" data-info="" class="language-"><code>言い換えれば、ガバナンスはそれぞれの業界の世界的リーダーとして世界的に認められ、
世界のあらゆる市場を代表する人々によって行われるべきです。
</code></pre></li>
<li>STABILITY<br>
Without technical and legal mechanisms to enforce the decisions of the 
governing body, public platforms are at risk of devolving into chaos.<pre data-role="codeBlock" data-info="" class="language-"><code>統治機関の決定を強制するための技術的および法的メカニズムがなければ、公共のプラットフォームは混乱に陥る危険があります。
</code></pre>Strong security and mature governance will enable a stable 
platform - one that engenders the necessary trust and confidence among 
those that would build commercial or sensitive applications on it.<pre data-role="codeBlock" data-info="" class="language-"><code>強力なセキュリティと成熟したガバナンスにより、安定したプラットフォームが可能になります。
これは、商用または機密アプリケーションを構築する人々の間で必要な信頼と信頼を生み出すものです。
</code></pre></li>
<li>REGULATORYCOMPLIANCE<br>
We expect that governments will continue to increase oversight of public ledgers and associated cryptocurrencies and tokens.<pre data-role="codeBlock" data-info="" class="language-"><code>我々は、政府が公的台帳ならびに関連する暗号通貨およびトークンの監視を強化し続けることを期待しています。
</code></pre>We consider that a distributed public ledger must be 
capable of enabling appropriate Know Your Customer (KYC) and Anti Money 
Laundering (AML) checks.<pre data-role="codeBlock" data-info="" class="language-"><code>私たちは、分配された公的台帳が適切なあなたの顧客を知る（KYC）および
Anti Money Laundering（AML）チェックを可能にすることができなければならないと考えます。
</code></pre></li>
</ol>
<h1 class="mume-header" id="%E7%96%91%E5%95%8F%E7%82%B9">疑問点</h1>

<table>
<thead>
<tr>
<th>No</th>
<th>概要</th>
<th>状態</th>
<th>調査業況</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>イベントを他ノードに通知する際には、<br>同じイベントがトランザクションの中に含まれてた場合、それも通知するのか。<br>そうすると同じものを延々と通知し続けることになりそうな気がする。</td>
<td>確認中</td>
<td>[2019/07/08]<br>コンセンサスアルゴリズムの資料確認中。</td>
</tr>
</tbody>
</table>
<h1 class="mume-header" id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</h1>

<ul>
<li><a href="https://note.mu/tech_entame/n/n6b82ee227cc3">【仕組み解説】ハッシュグラフ: ブロックチェーンを超える最新技術</a></li>
<li><a href="https://qiita.com/rinrin0108/items/ecd7399ea19bb03b1135">Hedera Hashgraphのコンセンサスアルゴリズム詳解</a></li>
</ul>

      </div>
      
      
    
    
    
    
    
    
    
    
  </body></html>